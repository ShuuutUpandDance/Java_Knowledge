## synchronized 与锁
利用 synchronized 实现同步的基础：**Java 中的每一个对象都可以作为锁**。具体表现为：

- 对于普通同步方法，锁是当前实例对象
- 对于静态同步方法，锁是所在类的 Class 对象
- 对于同步方法块，锁是人为指定的对象

在 JVM 中的实现原理：JVM 基于进入和退出 **Monitor 对象**来实现方法同步和代码块同步。**任何对象**都有一个 **monitor** 与之关联，JVM 通过 monitorenter 指令获取 monitor 的持有权，使用 monitorexit 指令释放持有权

#### 锁与 Java 对象头
synchronized 用的锁是**存在 Java 对象头里的 Mark Word 中**的。

#### 锁的升级与对比
1.6以后为了减少获得锁和释放锁带来的性能消耗，引入了“**偏向锁**”和“**轻量级锁**”。1.6中，锁一共有4种状态，级别**从低到高**依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，这几个状态会**随着竞争情况逐渐升级**。注意：锁可以升级但**不会降级**。
1. **偏向锁**
统计发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由**同一线程多次获得**，为了让线程获得锁的代价更低而引入偏向锁。——当一个线程访问同步块并获取锁时，会在**对象头（锁方面）**和**栈帧（线程方面）**中的锁记录中存储**锁偏向的线程 ID**，以后该线程进入和退出同步块时不再需要加锁解锁，而是只需简单测试**对象头中是否存储着指向当前线程的偏向锁（配对测试）**。如果测试成功，则表示线程已获得锁。如果测试失败（之前指向自己的偏向锁指向别的线程了/还没获得过偏向锁），则还需要测试对象头中的锁标记是否为偏向锁：如果没有设置（还没获得过偏向锁），则**竞争**锁；如果设置了（之前指向自己的偏向锁指向别的线程了），则**修改对象头中的偏向锁使其指向当前线程**。
    - 偏向锁的**撤销**。偏向锁只有被竞争时才会被撤销，撤销动作需要等待**全局安全点（当前时间点上没有正在执行的字节码）**。首先暂停拥有偏向锁的线程，然后检查该线程是否活着，如果线程不活动了，将**对象头**设置为**无锁状态**；如果线程还活着，则将锁偏向于其他线程（被修改）或恢复到无锁（被竞争）或被标记为不适合作为偏向锁（被频繁竞争）
    - **关闭**偏向锁。默认是启用的，如果有必要可以通过 JVM 参数关闭：-XX:-UseBiasedLocking=false，则程序会默认进入轻量级锁状态。

2. 轻量级锁
    - 加锁。线程在执行同步块前， JVM 会在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中（Displaced Mark Word）。然后该线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。**（只需要复制+修改就可以了，不需要上下文的切换）**如果成功，则获得锁；如果失败，则说明还有其他线程在竞争，于是尝试**自旋（循环询问）**来获取锁。
    - 解锁。使用 CAS 操作将 Displaced Mark Word 替换回对象头，如果成功，则表示没有竞争发生。如果失败，则表示当前锁存在竞争，锁会升级成为重量级锁（即通常意义上的锁）。

3. 重量级锁
因为轻量级锁中的**自旋**会消耗CPU，为了避免无用的自旋（比如获得锁的线程阻塞了，等待的线程就会持续消耗CPU），一旦锁升级成为重量级锁就不会再恢复成轻量级锁。此时，当其他线程视试图获取锁时，都会被阻塞住，直到持有锁的线程释放锁后唤醒阻塞线程，开始新一轮竞争。

4. 锁的优缺点对比

|锁|优点|缺点|使用场景|
|:--:|:--:|:--:|:--:|
|偏向锁|加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距|如果线程间存在竞争，将会带来额外的撤销锁的消耗|适用于长时间只有一个线程访问同步块的场景|
|轻量级锁|竞争的线程不会阻塞，提高了程序的响应速度|如果始终得不到锁竞争的线程，会使用自旋从而消耗CPU|追求响应时间、同步块执行速度非常快|
|重量级锁|线程竞争直接阻塞而不是使用自旋，不会消耗CPU|线程会阻塞，响应时间慢|追求吞吐量，同步块执行速度比较长|
